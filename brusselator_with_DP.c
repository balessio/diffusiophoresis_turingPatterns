#include "run.h"
#include "diffusion.h"
#include "advection.h"
#include "tracer.h"

/*
This code calculates the diffusiophoretic motion of two colloidal species in response to the
solute gradients generated by a Brusselator reaction diffusion system. It is based off of the
Basilisk example: http://basilisk.fr/src/examples/brusselator.c, where we simply add advective
diffusive tracers which advect porportional to the gradient of the solutes
*/

/*
C1 and C2 are the chemical concentrations
N1 and N2 are the diffusiophoretic colloids
uf1 and uf2 are their respective diffusiophoretic velocities
*/
scalar C1[], C2[];
scalar N1[], N2[], * tracers = {N1, N2};
face vector uf1[];
face vector uf2[];

/*
set no-flux boundary conditions
*/
N1[bottom] = neumann(0);
N1[top] = neumann(0);
N1[left] = neumann(0);
N1[right] = neumann(0);
N2[bottom] = neumann(0);
N2[top] = neumann(0);
N2[left] = neumann(0);
N2[right] = neumann(0);

/*
k is the Damk√∂hler number, ka is the initial concentration of C1,
D is the ratio of diffusivities of C1 and C2, mu in the supercriticality,
setL0 is the domain length (it's a square),
M's are the diffusiophoretic mobilities, D1 and D2 are the colloid diffusivities 
*/
double k = 1., ka = 1.5, D = 4;
double mu = 0.05, kb;
double setL0 = 64;
double M1_one = 0.025, M2_one = 0.035;
double M1_two = -0.025, M2_two = -0.035;
double hold_D1 = 2e-4, hold_D2 = 2e-4;
const face vector D1[] = {hold_D1,hold_D1};
const face vector D2[] = {hold_D2,hold_D2};

double dt;
mgstats mgd1, mgd2;

int main()
{
  init_grid (128*2);
  size (setL0);
  TOLERANCE = 1e-4;
  run();
}

event init (i = 0)
{
  double nu = sqrt(1./D);
  double kbcrit = sq(1. + ka*nu);
  kb = kbcrit*(1. + mu);

  foreach() {
    C1[] = ka ; 
    C2[] = kb/ka + 0.01*noise();
    N1[] = 1;
    N2[] = 1;
  }
}

event tracer_diffusion (i++)
{
  diffusion (N1, dt, D1);
  diffusion (N2, dt, D2);
}

event tracer_advection (i++)
{
  foreach_face() {
    uf1.x[] = (M1_one*(C1[] - C1[-1,0]) + M2_one*(C2[] - C2[-1,0]))/Delta;
  }

  foreach_face() {
    uf2.x[] = (M1_two*(C1[] - C1[-1,0]) + M2_two*(C2[] - C2[-1,0]))/Delta;
  }
  advection({N1}, uf1, dt);
  advection({N2}, uf2, dt);
}

event movie (i = 0; i += 20)
{
  output_ppm (C1, linear = true, spread = 2, file = "C1.mp4", n = 600);
  output_ppm (C2, linear = true, spread = 2, file = "C2.mp4", n = 600);
  output_ppm (N1, linear = true, spread = 2, file = "N1.mp4", n = 600);
  output_ppm (N2, linear = true, spread = 2, file = "N2.mp4", n = 600);
  fprintf (stderr, "%d %g %g %d %d\n", i, t, dt, mgd1.i, mgd2.i);

  if (i==0)
  {
    fclose(fopen("dataAll.txt", "w"));
  }
  FILE *out_file = fopen("dataAll.txt", "a"); // write only
  foreach() {
    fprintf(out_file, "%f %f %f %f %f %f %f\n", t, x, y, C1[], C2[], N1[], N2[]);
  }
  fclose(out_file);
}

event final (t = 1200)
{
  char name[80];
  sprintf (name, "C1_final.png");
  output_ppm (C1, file = name, n = 600, linear = true, spread = 2);
  sprintf (name, "C2_final.png");
  output_ppm (C2, file = name, n = 600, linear = true, spread = 2);
  sprintf (name, "N1_final.png");
  output_ppm (N1, file = name, n = 600, linear = true, spread = 2);
  sprintf (name, "N2_final.png");
  output_ppm (N2, file = name, n = 600, linear = true, spread = 2);

  fclose(fopen("dataFinal.txt", "w"));
  FILE *out_file = fopen("dataFinal.txt", "a"); // write only
  foreach() {
    fprintf(out_file, "%f %f %f %f %f %f %f\n", t, x, y, C1[], C2[], N1[], N2[]);
  }
  fclose(out_file);

}

event integration (i++)
{
  dt = dtnext (1.);

  scalar r[], beta[];
  
  // this is the Brusselator reaction diffusion system
  foreach() {
    r[] = k*ka;
    beta[] = k*(C1[]*C2[] - kb - 1.);
  }
  mgd1 = diffusion (C1, dt, r = r, beta = beta);
  foreach() {
    r[] = k*kb*C1[];
    beta[] = - k*sq(C1[]);
  }
  const face vector c[] = {D, D};
  mgd2 = diffusion (C2, dt, c, r, beta);
}

event adapt (i++) {
  adapt_wavelet ({N1,N2,uf}, (double[]){2e-1,2e-1,0.1,0.1},
          12, 5);
}
